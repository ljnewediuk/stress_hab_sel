
#################################################
###                                           ###
### Validates model by comparing              ###
### distributions of explanatory variables at ###
### observed and predicted presence locations ###
### (habitat characteristics associated with  ###
### used locations)                           ###
###                                           ###
### Returns df of used/available              ### 
### distributions and 95% CI bounds of        ### 
### predicted habitat characteristics of used ###
### points.                                   ###
###                                           ###
### Uses UHC plot process by Fieberg et al.   ###
### 2018  https://doi.org/10.1111/ecog.03123  ###
###                                           ###
#################################################

library(sf)
library(tidyverse)
library(uhcplots)
library(survival)

# Required columns:
#   id, period, case_, step_id_, cover, crop, cort_ng_g_sc, log_sl_, cos_ta_
# Arguments:
#   - Data: Name of data frame
#   - Period: "pre_calv" or "post_calv"
#   - Formula: 
#       - "crop": Contains all crop covariates and crop:cort interaction
#       - "cover": Contains all cover covariates and cover:cort interaction
#       - "crop_reduced": Crop model without interaction
#       - "cover_reduced": Cover model without interaction
#   - Individual ID: Name of elk 

uhc_validate <- function(dat, calv_period, model_form, elk_id, n_iterations) {
  
  # Name covariates
  if(model_form == 'cover') covs <- c('cover', 'cover:cort_ng_g_sc', 'log_sl_', 'cos_ta_')
  if(model_form == 'crop') covs <-c('crop', 'crop:cort_ng_g_sc', 'log_sl_', 'cos_ta_')
  if(model_form == 'cover_reduced') covs <- c('cover', 'log_sl_', 'cos_ta_')
  if(model_form == 'crop_reduced') covs <-c('crop', 'log_sl_', 'cos_ta_')
  
  # Select one elk and period (pre- or post-)
  indiv_dat <- dat %>%
    filter(id %in% elk_id & period == calv_period) %>%
    mutate(presence = ifelse(case_ == TRUE, 1, 0)) %>%
    rename('stratum' = step_id_)
  
  # Separate into training/testing data (2/3 training, 1/3 testing)
  train.steps <- sample(unique(indiv_dat$stratum), ceiling(length(unique(indiv_dat$stratum))/1.5))
  test.steps <- unique(indiv_dat$stratum)[! unique(indiv_dat$stratum) %in% train.steps]
  mdat.train <- indiv_dat %>%
    filter(stratum %in% train.steps)
  mdat.test <- indiv_dat %>%
    filter(stratum %in% test.steps)
  
  # Specify model formulas
  form1a <- reformulate(c(covs, 'strata(stratum)'), 'presence')
  form2a <- reformulate(c(covs, -1))
  
  # Fit training model
  ssf.train <- clogit(form1a, data=mdat.train)
  
  # Create simulation envelopes for the environmental characteristics at the 
  # observed locations in the test data (uhcsimstrat function)
  # Design matrix from test data for SSF
  design.mat.test <- model.matrix(form2a, data=mdat.test)
  # Design matrix for covariates z (matrix of used & available environmental
  # characteristics in the test data)
  z <- model.matrix(form2a, data = mdat.test)[,-5]
  # Simulate from model x n_iterations
  xchoice <- uhcsimstrat(nsims = n_iterations,
                         xmat = design.mat.test, 
                         stratum = mdat.test$stratum, 
                         fit_ssf = ssf.train,
                         z = z)   
  
  # Get density estimates for habitat characteristics of observed locations in 
  # test data and associated with random locations generated by uhcsim
  
  # Initiate a df
  denshats_df <- data.frame()
  for(i in 1:length(covs)) {
    # Calculate density estimates
    denshats <- uhcdenscalc(rand_sims = xchoice[,,i], 
                            dat = z[mdat.test$presence==1,i], 
                            avail = z[mdat.test$presence==0,i],
                            gridsize = 500) 
    # Bind covariates with remaining data frame
    denscov <- data.frame(
      # Name the individual
      id = ifelse(length(elk_id) == 1, elk_id, NA),
      # Specify period
      period = calv_period,
      # Specify model type
      model_form,
      covariate = covs[i],
      # Get quantiles of the predicted distribution of the variable at used points
      densrand_l = apply(denshats[["densrand"]], 2,
                         function(x) quantile(x, probs = c(0.025, 0.975), na.rm = T))[1 ,],
      densrand_h = apply(denshats[["densrand"]], 2,
                         function(x) quantile(x, probs = c(0.025, 0.975), na.rm = T))[2 ,],
      # Get the actual variable distribution at used points
      densdat_x = denshats[["densdat"]]$x,
      densdat_y = denshats[["densdat"]]$y,
      # Get available distribution at used points
      densavail_x = denshats[["densavail"]]$x,
      densavail_y = denshats[["densavail"]]$y
    )
    # Bind together dataframes for all covariates
    denshats_df <- rbind(denshats_df, denscov)
  }

  return(denshats_df)
  
}
